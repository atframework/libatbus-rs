syntax = "proto3";

import "libatbus_options.proto";

package atbus.protocol;

option optimize_for = SPEED;
// option optimize_for = LITE_RUNTIME;
// option optimize_for = CODE_SIZE;
// --cpp_out=lite:,--cpp_out=
option cc_enable_arenas = true;

enum ATBUS_PROTOCOL_CONST {
  option allow_alias                   = true;
  ATBUS_PROTOCOL_CONST_UNKNOWN         = 0;
  ATBUS_PROTOCOL_CONST_MAGIC_NUMBER    = 16777619; // 0x1000193
  ATBUS_PROTOCOL_CONST_VERSION         = 3;
  ATBUS_PROTOCOL_CONST_MINIMAL_VERSION = 3; // minimal protocol version supported

  // Internal packet type, user custom type should be greater than this.
  ATBUS_PROTOCOL_CONST_INTERNAL_PACKET_TYPE = 1000;
}

enum ATBUS_PACKET_FLAG_TYPE {
  AATBUS_PACKET_FLAG_TYPE_NONE = 0; // default value

  // This is not the last frame of current packet.
  // When this flag is set, we need wait for more frame to finish this packet
  ATBUS_PACKET_FLAG_TYPE_PACKET_CONTINUATION = 1;

  // Finish current stream, similar to FIN of TCP
  // Receiver should destroy this stream when got this flag
  ATBUS_PACKET_FLAG_TYPE_FINISH_STREAM = 2;

  // Finish current connection, similar to FIN of TCP
  // Receiver should destroy this connection when got this flag
  ATBUS_PACKET_FLAG_TYPE_FINISH_CONNECTION = 4;

  // Reset sequence.
  // When endpoints are first created or receive a packet_data with acknowledge lower than the first message in queue
  // We need to send a packet_data with ATBUS_PACKET_FLAG_RESET_SEQUENCE
  ATBUS_PACKET_FLAG_TYPE_RESET_SEQUENCE = 8;
}

enum ATBUS_PACKET_TYPE {
  ATBUS_PACKET_TYPE_DATA    = 0;
  ATBUS_PACKET_TYPE_COMMAND = 1;
}

message stream_acknowledge {
  int64 stream_id = 1;

  // All datas before this offest are received.(Not include)
  int64 acknowledge_offset = 2;
}

message ping_data {
  repeated stream_acknowledge acknowledge = 1;

  int64 timepoint_seconds = 3;
  int32 timepoint_nanos   = 4;
}

message forward_data {
  int32 version       = 1;
  bytes source        = 2;
  bytes scheme        = 3;
  bytes address       = 4;
  int32 port          = 5;
  int64 connection_id = 6;
}

message packet_data {
  // Stream id is used for concurrency transfer.Just like Stream ID in HTTP/3
  // We can transfer different stream on different connection to improve throughput
  int64 stream_id     = 1;
  int64 stream_offset = 2;
  bytes content       = 3;
  int32 packet_type   = 4; // @see ATBUS_INTERNAL_PACKET_TYPE
  // When flags contains ATBUS_PACKET_FLAG_PACKET_CONTINUATION, packet_length should be set.
  int64 packet_length = 5;
  // @see ATBUS_PACKET_FLAG_TYPE
  int32          flags   = 6;
  packet_options options = 7;
  // https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
  // https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/cri-api/pkg/apis/runtime/v1/api.proto
  map<string, string> labels = 8; // allow custom labels

  // This field should exists when first create a relay connection
  forward_data forward_for = 11;
}

message acknowledge_data {
  stream_acknowledge acknowledge = 1;

  int64 timepoint_seconds = 3;
  int32 timepoint_nanos   = 4;

  // Tell relaysvr to acknowledge forward connection,so relaysvr will not fill packet_data.forward_for
  // for this connection any more.
  forward_data forward_for = 11;
}

message message_head {
  int32 version                   = 1;
  bytes source                    = 2;
  bytes destination               = 3;
  bytes forward_for_source        = 4; // Always filled by relaysvr
  int64 forward_for_connection_id = 5; // Always filled by relaysvr
}

message frame_message {
  message_head head = 1;
  oneof        body {
    ping_data        node_ping   = 11;
    ping_data        node_pong   = 12;
    packet_data      packet      = 13;
    acknowledge_data acknowledge = 14;
  }
}
